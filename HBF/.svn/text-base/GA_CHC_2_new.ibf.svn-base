/*---------------------------------------------------------------------------------------------------------------------------------------------  SPAWN INITIAL POPULATION; IT IS STORED AS GENERATING MATRICES---------------------------------------------------------------------------------------------------------------------------------------------*/resultProcessingContext = 0;compressedString 		= {};optimizeBLFlag 			= 1;for (individual=0; individual<populationSize; individual=individual+1){	sortedScores[individual][1] 	= individual;	cString							= currentPopulation[individual];	RunASample (compressedString[rateClassesCount-1],individual);}sortedScores = sortedScores%0;sampleProbs = {populationSize,1};doMutation = 0;lastImprovedGeneration   = 0;lastBestAIC		  		 = 1e100;lastBranchAIC		     = currentBEST_IC;mutationProb			 = mutationProbStart;incestDistance			 = 4;localSamplingProbs		 			= {2*currentBPC+2,1}["1"];localSamplingProbs [2*currentBPC+1] = 2*currentBPC+1;localSpread							= 0.15;finalConvergenceCheck				= -1;/*lastLocalMutation					= 0;*//*---------------------------------------------------------------------------------------------------------------------------------------------  RUNS THE CHC;---------------------------------------------------------------------------------------------------------------------------------------------*/for (generation=0; generation<generationCount; generation=generation+1){		timeSoFar = Time(1)-startTimer;		if (verboseFlag)	{		bestIndDesc = ConvertToPartString (currentPopulation[sortedScores[populationSize-1][1]]);		newSub = AssembleSubtypeAssignment(bestIndDesc,0);		if (runSubpopulations)		{			fprintf (stdout, "\nPASS ", subpop, " OF ", runSubpopulations, " SUBPOPULATIONS");		}		fprintf (stdout, "\nGeneration ", generation+2, " with ", currentBPC, " breakpoints.\n",bestIndDesc,"\n",newSub,"\n",currentBEST_IC+sortedScores[populationSize-1][0]);		if (Abs(correctModel))		{			fprintf (stdout, "\n",correctModelAIC+sortedScores[populationSize-1][0]);			}							   		percDone = 100*(generation-lastImprovedGeneration)/stoppingCriterion$1;		  					  			fprintf (stdout, "\nGA has considered ", Abs (MasterList)-current_BPP_done_counter, "/", Format(totalModelCounter,12,0), " (", Abs (MasterList) ," over all runs) unique models",							   "\nTotal run time: ", timeSoFar$3600, " hrs ", timeSoFar%3600$60, " mins ", timeSoFar%60, " seconds. ",							   "Throughput: ", Format (Abs(MasterList)/timeSoFar, 5, 2), " models/second.\n",							   percDone, "% converged\n");	}		if (verboseFlag==4)	{		for (individual=0; individual<populationSize; individual=individual+1)		{			fprintf (stdout, individual, ":", ConvertToPartString (currentPopulation[individual]), "\n");		}	}						  	genBestAIC = -sortedScores[populationSize-1][0];	if (genBestAIC + 0.001 < lastBestAIC)	{		if (runInMPIMode == 0 && currentBEST_IC+sortedScores[populationSize-1][0] > 0.001)		{			EchoSubtypeUpdate(currentPopulation[sortedScores[populationSize-1][1]]);		}		lastBestAIC 				= -sortedScores[populationSize-1][0];		lastImprovedGeneration 		= generation;		finalConvergenceCheck  		= -1;	} 	else	{		if (generation-lastImprovedGeneration>=stoppingCriterion)		{			/*cString   		 = currentPopulation[populationSize-1];			localPartCount	 = (Rows (cString) - branchBits) $ bitsPerPart * 2 + 1;			if (finalConvergenceCheck >= localPartCount-1)			{				break;			}			else			{				finalConvergenceCheck = finalConvergenceCheck + 1;			}*/			break;		}	}	if ((generation+1) % annealingPhase == 0)	{		mutationProb = Max(mutationProbMin,mutationProb*mutationProbDecrease);	}	children 	    = {};	doRepop 		= 1;	doLocalMutation = generation-lastImprovedGeneration;	doLocalMutation = doLocalMutation*((doLocalMutation % localMutationInterval) == 0);	if (doLocalMutation || finalConvergenceCheck >= 0)	{		if (finalConvergenceCheck >= 0)		{			doLocalMutation = 1;			finalConvergenceCheck = finalConvergenceCheck + 1;			cString   		 = currentPopulation[populationSize-1];			localPartCount	 = (Rows (cString) - branchBits) $ bitsPerPart * 2 + 1;			if (finalConvergenceCheck == localPartCount)			{				doLocalMutation = 0;				finalConvergenceCheck = -1;			}		}		else		{			finalConvergenceCheck = 0;		}	}	if (doMutation || doLocalMutation)	{		resultProcessingContext = 0;		mutProb   = mutationProb;		if (doLocalMutation)		{			startFrom 			= 2*populationSize$3;			populationStrings 	= {};			for (individual=startFrom; individual<populationSize; individual=individual+1)			{				populationStrings[ConvertToPartString(currentPopulation[individual])] = 1;			}						/* pick which part to mutate */						cString   		 = currentPopulation[populationSize-1];			localPartCount	 = (Rows (cString) - branchBits) $ bitsPerPart * 2 + 1;						if (finalConvergenceCheck < 0)			{				goFrom		 	 = Random (0,1);				stepper			 = 0;				whichFrag		 = 0;					if (verboseFlag>2)				{					fprintf (stdout, localSamplingProbs, "\n", goFrom, "\n");				}					while(stepper < goFrom)				{					stepper = stepper + localSamplingProbs[whichFrag]/localSamplingProbs[localPartCount];					whichFrag = whichFrag+1;				}								whichFrag = whichFrag-1;							localSamplingProbs = localSamplingProbs + localSamplingProbs["_MATRIX_ELEMENT_ROW_!=whichFrag"];				localSamplingProbs [localPartCount] = localSamplingProbs [localPartCount] + (localPartCount-2);			}			else			{				whichFrag = finalConvergenceCheck;			}						if (whichFrag%2)			{				normalizer  = bppMapSize;				stepper	    = bppSize;				startAt	    = (whichFrag-1)$2*bitsPerPart + branchBits;				cLoc	    = binaryToDecimal (cString,startAt,stepper)%normalizer;				if (finalConvergenceCheck < 0)				{					goFrom		= (Random(-localSpread,localSpread)*normalizer)$1;				}				else				{					goFrom 		= -startFrom$2				}				goFrom 	    = Max(0,cLoc + goFrom);				localSpread = Random (0.05,0.35);			}			else			{				normalizer = tbc;				stepper	   = branchBits;				if (whichFrag)				{					startAt = (whichFrag-1)$2*bitsPerPart+branchBits+bppSize;				}				else				{					startAt = 0;				}				if (finalConvergenceCheck < 0)				{					goFrom = Random(0, normalizer-0.00001)$1;				}				else				{					goFrom = Max(startAt - startFrom$2,0);				}			}						if (verboseFlag>2)			{				baseString = ConvertToPartString (cString);				fprintf (stdout, "\nLocal Mutation On Fragment:", whichFrag,"\n", baseString,"\n",cString,"\n",MakeStringCanonical(cString,-1),"\n",startAt,"\n",cLoc,":",goFrom,"\n\n");			}						for (individual=0; individual<startFrom; individual=individual+1)			{				cString   		 = currentPopulation[populationSize-1];								decimalToBinary ("cString",startAt,stepper,goFrom%normalizer);				if (verboseFlag>2 && currentBPC > 1)				{					fprintf (stdout, goFrom, ":: ",  ConvertToPartString (MakeStringCanonical(cString,-1)), "\n");				}				goFrom 			 = goFrom+1;				cString 		 = IsChildViable		  (MakeStringCanonical (cString,rateClassesCount));				populationStrings [sampleString] = 1;								sortedScores[individual][1]		 = individual;				currentPopulation[individual] 	 = cString;				RunASample (0,individual);							if (verboseFlag>2)				{					fprintf (stdout, _ModelKeyString, "\n");				}			}		}		else		{			startFrom = populationSize-2;		}				if (doLocalMutation == 0)		{			populationStrings = {};			populationStrings[ConvertToPartString(currentPopulation[populationSize-1])] = 1;			for (individual=startFrom; individual>=0; individual=individual-1)			{				cString = currentPopulation[individual];				if (verboseFlag>5)				{					beforeMut = ConvertToPartString(cString);				}				mpos	= 0;				/*				endIndex   = stateVectorDimension;				startIndex = 0;				*/								whichPart = Random(0,2*currentBPC+1)$1;								if (whichPart % 2)				{					startIndex = (whichPart$2+1)*bitsPerPart-bppSize;					endIndex   = startIndex + 2*branchBits + bppSize;				}				else				{					startIndex = (whichPart$2)*bitsPerPart;					endIndex   = startIndex + bitsPerPart + 2*bppSize;									}				endIndex = Min(endIndex, stateVectorDimension);								for (h=startIndex; h<endIndex; h=h+1)				{					if (Random(0,1)<mutProb)					{						 cString[h] = 1-cString[h];						 mpos = mpos + 1;					}				}				if (mpos == 0)				{					h = Random(startIndex, endIndex)$1;				    cString[h] = 1-cString[h];					mpos = 1;				}				cString = IsChildViable		  (MakeStringCanonical (cString,rateClassesCount));				populationStrings[sampleString] = 1;				sortedScores[individual][1] = individual;				currentPopulation[individual] = cString;				if (verboseFlag>5)				{					fprintf (stdout, "Mutated ", Format (mpos, 4, 0), " position in individual ", individual+1, " from \n", beforeMut, "\nto\n",ConvertToPartString(cString),"\n" );				}				RunASample (compressedString[rateClassesCount-1],individual);			}				}		CleanUpMPI (0);		doMutation = 0;		sortedScores = sortedScores%0;		continue;	}	resultProcessingContext = 1;	fitnessSum = 0;	intermediateProbs = {populationSize+produceOffspring,2};            if (matingChoice == 3)    {		lmatingChoice = Random(0,2.9999999999999)$1;	}	else	{		lmatingChoice = matingChoice;	}		for (individual=0; individual<populationSize; individual=individual+1)	{		if (lmatingChoice==0)		{			sampleProbs[individual] = Exp((sortedScores[individual][0]-sortedScores[populationSize-1][0])/2);		}		else		{			if (lmatingChoice == 1)			{				sampleProbs[individual] = 1;					}			else			{				sampleProbs[individual] = 2*(individual+1);								}		}		intermediateProbs[individual][0] = sortedScores[individual][0];		intermediateProbs[individual][1] = sortedScores[individual][1];		fitnessSum 						 = fitnessSum + sampleProbs[individual];	}		sampleProbs = sampleProbs*(1/(({1,populationSize}["1"])*sampleProbs)[0]);	/*	fprintf (stdout, sampleProbs);	*/		populationStrings = {};	for (individual=0; individual<populatioSize; individual=individual+1)	{		populationStrings [ConvertToPartString(currentPopulation[individual])] = 1;	}		for (individual=0; individual<produceOffspring; individual=individual+1)	{		/* pick two individuals to produce offspring */		/* pick 1st parent */		h 			       = Random (0,1);		fitnessSum		   = sampleProbs[0];		v = 0;		while (fitnessSum < h)		{			v = v+1;			fitnessSum = fitnessSum + sampleProbs[v];		}		p1 			   = sortedScores[v][1];		ps1			   = currentPopulation[p1];		goOn 		   = 1;				disallowedProbs 	= sampleProbs[v];				for (sampleTry = 0; (sampleTry < maxSampleTries) && goOn; sampleTry = sampleTry + 1)		{			goOn 		   = 0;			if (disallowedProbs<1)			{				h 			   = Random (0,1-disallowedProbs);				if (v == 0)				{					fitnessSum	   = 0;							}				else				{					fitnessSum	   = sampleProbs[0];				}								v2 = 0;				while (fitnessSum < h)				{					v2 = v2 + 1;					if (v2 == populationSize)					{						while (v2==v)						{							v2 = Min(Random (0,populationSize)$1,populationSize-1);						}						break;					}					if (v2!=v)					{						fitnessSum = fitnessSum + sampleProbs[v2];					}				}				}			else			{				v2 = v;				while (v2==v)				{					v2 = Min(Random (0,populationSize)$1,populationSize-1);				}			}						if (v2 == populationSize)			{				goOn = 1;				continue;			}									p2 = sortedScores[v2][1];			ps2			   = currentPopulation[p2];			fitnessSum 	   = 0;		}				if (sampleTry == maxSampleTries)		{			fprintf (stdout, "sampleTry == maxSampleTries", "\n");						doMutation = 1;			generation = generation - 1;			CleanUpMPI (0);			doRepop = 0;			break;		}		else		{			diffVec		   = ps1-ps2;			diffVec		   = diffVec["_MATRIX_ELEMENT_VALUE_"];			fitnessSum	   = Transpose(diffVec["1"])*diffVec;						if (incestDistance<=fitnessSum[0])			{				if (verboseFlag>5)				{					fprintf (stdout, "Mating ", p1, " and ", p2, ". Difference of ", fitnessSum[0], " positions\n");				}				aChild = {stateVectorDimension,1};								if (Random(0,1)>swapBeforeMateProb)				{					if (mildMatingProcess)					{						cString = Random(0,stateVectorDimension)$1;												for (h=0; h<cString; h=h+1)						{							aChild[h] = ps1[h];						}						for (; h<stateVectorDimension; h=h+1)						{							aChild[h] = ps2[h];						}										}					else					{										for (h=0; h<stateVectorDimension; h=h+1)						{							if (Random(0,1)<0.5)							{								aChild[h] = ps1[h];							}							else							{								aChild[h] = ps2[h];												}						}					}				}				else				{					if (Random(0,1) < 0.5)					{						aChild = swapBreakpoints (ps1);					}					else					{						aChild = swapBreakpoints (ps2);										}				}								positionsToMutate = Random (0,1+(stateVectorDimension*mutateAfterMate))$1;				if (positionsToMutate)				{					templateVector = {1,stateVectorDimension}["_MATRIX_ELEMENT_COLUMN_"];					templateVector = (Random(templateVector,0))[{{0,0}}][{{0,positionsToMutate-1}}];					for (h=0; h<positionsToMutate; h=h+1)					{						aChild[templateVector[h]] = 1-aChild[templateVector[h]];					}					/*					fprintf (stdout, "MutateD ", templateVector, "\n");					*/				}								cString = IsChildViable (MakeStringCanonical (aChild,rateClassesCount));				populationStrings [sampleString] = 1;				intermediateProbs[populationSize+individual][1] = populationSize+individual;				children  [individual] = cString;				RunASample (compressedString[rateClassesCount-1],populationSize+individual);			}			else			{				children  [individual] 							= currentPopulation[populationSize-1];				intermediateProbs[populationSize+individual][0] = -1e25;					}		}	}	if (doRepop)	{		newPop = {};		intermediateProbs = intermediateProbs%0;		insertedOffspring = 0;				for (h=produceOffspring; h<populationSize+produceOffspring; h=h+1)		{			v = intermediateProbs[h][1];			sortedScores[h-produceOffspring][1] = h-produceOffspring;			sortedScores[h-produceOffspring][0] = intermediateProbs[h][0];					if (v<populationSize)			{				newPop[h-produceOffspring] = currentPopulation[v];			}			else			{				newPop[h-produceOffspring] = children[v-populationSize];				insertedOffspring = insertedOffspring + 1;			}		}		for (h=0; h<populationSize; h=h+1)		{			currentPopulation[h] = newPop[h];		}				h = Abs((sortedScores[populationSize-1][0]-sortedScores[0][0])/sortedScores[0][0]);				if (verboseFlag)		{			fprintf (stdout, "Diversity level: ", h, " (hypermutation threshold: ", mutationThreshhold, ")\nIncest Distance: ",incestDistance,						     "\nInserted Offspring: ", insertedOffspring, "\n");			}		if (insertedOffspring == 0)		{			incestDistance = incestDistance-1;			if (incestDistance>0)			{				generation = generation - 1;			}			else			{				incestDistance			 = 4;				}		}				if (h<mutationThreshhold || incestDistance == 0)		{			if (verboseFlag)			{				fprintf (stdout, "\nTriggered hypermutation...\n");			}			doMutation = 1;			generation = generation - 1;		}	}	if (Abs(MasterList)-current_BPP_done_counter >= totalModelCounter)	{		break;	}}/*fprintf (stdout, "CONVERGED?\n", generation, "\n", generationCount, "\n",lastImprovedGeneration,"\n",stoppingCriterion,"\n");*/